

continue with loading page from disk:
    make MMU store faulted virtual address (if it doesn't already)
    in fault handler, retrieve faulted virtual address from MMU
        currently we're only getting the faulted PTE
        we need the virtual address to know what virtual page / page table we're fetching, and to store that info in the physical page map
    update the physical page map
        make process ID not hardcoded
        make page directory physical block not hardcoded
            accessible from the process map once we know the process ID
    update the process map

Fix virtual disk so that writing 4 bytes to the transfer register doesn't initiate 4 transfers
    just make the nominal byte start the transfer

====================================================================================

Change simulator to accept configuration file as command line argument to set up memory, MMIO devices, etc.

Document current state of assembler and assembler pro functionality

====================================================================================

Determine how to handle reading / writing over page boundaries
	Currently, environment gets translated base address from the MMU
	Processor can only read and write 4 bytes at a time due to using 4 byte registers
	The processor could issue a read where the base address is translated without fault (first byte is in bounds)
		The fourth byte might be on a different page, but the MMU can't stop reading this byte because the environment
		takes the MMU-translated address and just reads the next 4 addresses

====================================================================================

change processor current instruction debugger display to show the instruction expansion ("src -> dst")

continue testing the test program

====================================================================================

Change processor to only access memory when the current instruction requires it
	Do not prematurely fetch COMPR, IADN, IADF, RMEM, WMEM
	Will this prevent any problems?

Update trap to new model

====================================================================================

Tests
	Write tests for processor functionality
		Test programs for processor instructions
		Tests for trap functionality
	Complete TestMain
		Add assembler method to read in dumped assembly to assembler.assembly_data
		Add a way to create correct output
			Change processor to write state to output file
	

Look into changing MMIO to allow enter/exit read/write mode
	Processor can only issue one write at a time
		This is due to the available instructions of the processor, not the design of the MMIO interface
	Moving large amounts of memory to IO devices would require acquiring and releasing locks over and over again
		It would also require many instructions
		Therefore, there is a high cost for both the processor in the simulation and running the simulation
	Alternative: create a DMA (direct memory access) controller IO device
		Processor sends signal and address to DMA controller
		DMA controller writes range of data from memory to MMIO device with single call to device's write_memory()
			Therefore mininmizing lock acquisition

Processor visualizer (new)
	Add register listeners to processor visualizer
		Cue visualizations based on register contents (like changing color of FLAG name)
	Make FLAG name change color when system halts
		Possibly by implementing register listeners
	Move the visualizer outside of the processor class
		Living inside the processor makes accessing registers very simple, which is common for the visualizer
		Maybe the visualizer can be a nested class
	Change the memory context preview readouts to work with virtual addressing
		Processor visualizer must not raise interrupts or page table faults
		Perhaps color preview along page boundaries, conditional on status of the page
			(kernel, unmapped, dirty, etc.)


Assembler
	Create a new layer for the assembler which can strip comments and other styling
	The goal is to enable writing assembly in a style that's easier to understand

Simulation environment
	Create the MMU
		MMU must replace address translation system
			MMU cannot be a normal MMIO device because reads/writes to all adresses must go through the MMU
		To run the processor in "bare metal" mode, the simulation environment should allow disabling the MMU
			All addresses still pass through the MMU, it just doesn't translate them

Operating system
	Interrupt handlers
		MMU interrupts
		Timer interrupts
		Syscall interrupts
		IO interrupts
	Kernel boot process
		Initializing page tables
		Initiating the hardware timer for preemption
	Kernel scheduler

Virtual keyboard
	Create virtual keyboard
	Runs its own thread that listens for Console.readkey()
	When key is pressed
		Save the keypress
		Send interrupt to processor

Page table
	Establish page table layout that both MMU and OS can use

Change writes to FLAG to always set MSB to 0
	Only the trap should be allowed to enable ignore interrupts