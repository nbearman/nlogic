-- -- -- -- |	//=========================================================================
-- -- -- -- |	// kernel entry point
-- -- -- -- |	//=========================================================================
-- -- -- -- |	
-- -- -- -- |	//========
-- -- -- -- |	// DMEM region (0x00 - 0x3F)
-- -- -- -- |	//========
-- -- -- -- |	// IMPORTANT: instructions here will be overwritten when DMEM is written to (like dumping registers in interrupt handler)
-- -- -- -- |	
-- -- -- -- |	// PC is at 0x08 when MMU is enabled, so these won't be executed
00 00 00 00 |	00 00
00 00 00 02 |	00 00
00 00 00 04 |	00 00
-- -- -- -- |	
-- -- -- -- |	//kernel entry point; MMU enabled, we're in VA now
-- -- -- -- |	
-- -- -- -- |	//set the MMU VA break point
00 00 00 06 |	IADF WBASE
00 00 00 08 |	SKIP PC
00 00 00 0A |	00 00 10 00 //MMIO base address (in VA)
00 00 00 0E |	08 WOFST //breakpoint register
00 00 00 10 |	00 WMEM //breakpoint at 0
-- -- -- -- |	
-- -- -- -- |	//enable the breakpoint
00 00 00 12 |	14 WOFST //breakpoint enabled register
00 00 00 14 |	01 WMEM //non-zero -> enabled
-- -- -- -- |	
00 00 00 16 |	00 RBASE
00 00 00 18 |	00 ROFST
-- -- -- -- |	
-- -- -- -- |	//jump to 0 in user space
00 00 00 1A |	00 PC
-- -- -- -- |	// end kernel entry code
-- -- -- -- |	
-- -- -- -- |	//TODO unused space 0x40 - 0x100
-- -- -- -- |	
00 00 00 1C |	FILL100 //data should start after DMEM accessible region (0x00 - 0x3F) so it can't be overwritten by DMEM instructions
-- -- -- -- |	//=========================================================================
-- -- -- -- |	// kernel data structures
-- -- -- -- |	//=========================================================================
-- -- -- -- |	@@physical_page_map
-- -- -- -- |	//physical page map
-- -- -- -- |	
-- -- -- -- |	//TODO this struct can be made smaller by packing some variables into a single uint
-- -- -- -- |	//  process id, phsyical page, and number of references will never be close to 4 bytes in size
-- -- -- -- |	//=========================
-- -- -- -- |	// physical page mapping entry
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   process id
-- -- -- -- |	// 0x04 |   uint    |   directory physical page
-- -- -- -- |	// 0x08 |   uint    |   virtual page number
-- -- -- -- |	// 0x0C |   uint    |   number of references
-- -- -- -- |	// 0x10 |   uint    |   disk block number
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	//boot sequence (no owner)
00 00 01 00 |	00 00 00 00
00 00 01 04 |	00 00 00 00
00 00 01 08 |	00 00 00 00
00 00 01 0C |	00 00 00 00
00 00 01 10 |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//kernel page directory
00 00 01 14 |	00 00 00 01 //kernel process ID == 1
00 00 01 18 |	00 00 00 01 //owning page directory is this directory, kernel's page directory
00 00 01 1C |	00 00 00 00 //this is a directory
00 00 01 20 |	00 00 00 01 //kernel process references this physical page
00 00 01 24 |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//kernel page table 0
00 00 01 28 |	00 00 00 01 //kernel process ID == 1
00 00 01 2C |	00 00 00 01 //owning page directory is kernel directory
00 00 01 30 |	00 00 00 00 //virtual table 0
00 00 01 34 |	00 00 00 01 //kernel process references this physical page
00 00 01 38 |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//kernel virtual page 0
00 00 01 3C |	00 00 00 01 //kernel process ID == 1
00 00 01 40 |	00 00 00 01 //owning page directory is kernel directory
00 00 01 44 |	00 00 00 00 //virtual page 0
00 00 01 48 |	00 00 00 01 //kernel process references this physical page
00 00 01 4C |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//empty (no owner)
00 00 01 50 |	00 00 00 00
00 00 01 54 |	00 00 00 00
00 00 01 58 |	00 00 00 00
00 00 01 5C |	00 00 00 00
00 00 01 60 |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//user page directory
00 00 01 64 |	00 00 00 02 //user process ID == 2
00 00 01 68 |	00 00 00 05 //owning page directory is this directory, user's page directory
00 00 01 6C |	00 00 00 00 //this is a directory
00 00 01 70 |	00 00 00 01 //user process references this physical page
00 00 01 74 |	00 00 00 00 //no disk block number yet
-- -- -- -- |	
-- -- -- -- |	//user page table 0
00 00 01 78 |	00 00 00 02 //user process ID == 2
00 00 01 7C |	00 00 00 05 //owning page directory is user page directory
00 00 01 80 |	00 00 00 00 //virtual table 0
00 00 01 84 |	00 00 00 01 //user process references this physical page
00 00 01 88 |	00 00 00 00 //no disk block number yet
-- -- -- -- |	
-- -- -- -- |	//user virtual page 0
00 00 01 8C |	00 00 00 02 //user process ID == 2
00 00 01 90 |	00 00 00 05 //owning page directory is user page directory
00 00 01 94 |	00 00 00 00 //virtual page 0
00 00 01 98 |	00 00 00 01 //user process references this physical page
00 00 01 9C |	00 00 00 64 //loaded from disk block 100
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//empty (no owner)
00 00 01 A0 |	00 00 00 00
00 00 01 A4 |	00 00 00 00
00 00 01 A8 |	00 00 00 00
00 00 01 AC |	00 00 00 00
00 00 01 B0 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 01 B4 |	00 00 00 00
00 00 01 B8 |	00 00 00 00
00 00 01 BC |	00 00 00 00
00 00 01 C0 |	00 00 00 00
00 00 01 C4 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 01 C8 |	00 00 00 00
00 00 01 CC |	00 00 00 00
00 00 01 D0 |	00 00 00 00
00 00 01 D4 |	00 00 00 00
00 00 01 D8 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 01 DC |	00 00 00 00
00 00 01 E0 |	00 00 00 00
00 00 01 E4 |	00 00 00 00
00 00 01 E8 |	00 00 00 00
00 00 01 EC |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 01 F0 |	00 00 00 00
00 00 01 F4 |	00 00 00 00
00 00 01 F8 |	00 00 00 00
00 00 01 FC |	00 00 00 00
00 00 02 00 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 02 04 |	00 00 00 00
00 00 02 08 |	00 00 00 00
00 00 02 0C |	00 00 00 00
00 00 02 10 |	00 00 00 00
00 00 02 14 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 02 18 |	00 00 00 00
00 00 02 1C |	00 00 00 00
00 00 02 20 |	00 00 00 00
00 00 02 24 |	00 00 00 00
00 00 02 28 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 02 2C |	00 00 00 00
00 00 02 30 |	00 00 00 00
00 00 02 34 |	00 00 00 00
00 00 02 38 |	00 00 00 00
00 00 02 3C |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//end physical page map (32 page mappings)(TODO only 16 shown; space reserved for the rest with FILL)
00 00 02 40 |	FILL380
-- -- -- -- |	
-- -- -- -- |	@@process_map
-- -- -- -- |	//process map
-- -- -- -- |	
-- -- -- -- |	//=========================
-- -- -- -- |	// process map entry
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   process id
-- -- -- -- |	// 0x04 |   uint    |   number of mapped virtual pages
-- -- -- -- |	// 0x08 |   uint    |   number of pages resident in memory
-- -- -- -- |	// 0x0C |   uint    |   disk block of process page directory
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	//kernel process descriptor
00 00 03 80 |	00 00 00 01 //kernel process ID == 1
00 00 03 84 |	00 00 00 03 //3 pages are mapped: 2 pages of memory and 1 mapped to the MMU
00 00 03 88 |	00 00 00 03 //page directory, page table, 1 page of memory
00 00 03 8C |	00 00 00 00 //no disk block number, kernel page directory can never be evicted
-- -- -- -- |	
-- -- -- -- |	//user process descriptor
00 00 03 90 |	00 00 00 01 //user process ID == 2
00 00 03 94 |	00 00 00 03 //2 pages are mapped: 2 pages of memory
00 00 03 98 |	00 00 00 03 //page directory, page table, 1 page of memory
00 00 03 9C |	00 00 00 00 //TODO figure out if we're supposed to load process page directory from disk...
-- -- -- -- |	            //(it should probably be built dynamically from some kind of description file
-- -- -- -- |	            // that the kernel can read to determine how many pages of the program are
-- -- -- -- |	            // mapped out of the box [length of program data])
-- -- -- -- |	
-- -- -- -- |	//end process map (16 process descriptors)
00 00 03 A0 |	FILL480
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//TODO unused space between 0x480 and 0x500
-- -- -- -- |	//  interrupt handler could be moved to 0x480
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//=========================================================================
-- -- -- -- |	// interrupt handler
-- -- -- -- |	//=========================================================================
00 00 04 80 |	FILL500
-- -- -- -- |	//Fill to place the interrupt handler code at the correct location
-- -- -- -- |	    //TODO the address of the interrupt handler is currently hardcoded in the simulation environment
-- -- -- -- |	    //interrupt_handler_address in Processor class
-- -- -- -- |	
-- -- -- -- |	//==============================
-- -- -- -- |	// DMEM region layout
-- -- -- -- |	// Data dumped automatically from last instruction cache
-- -- -- -- |	//=====================
-- -- -- -- |	// 0x00 |   uint    |   WBASE temporary dump
-- -- -- -- |	// 0x04 |   uint    |   WOFST temporary dump
-- -- -- -- |	
-- -- -- -- |	// 0x08 - 0x24      |   (unused)
-- -- -- -- |	
-- -- -- -- |	// 0x28 |   uint    |   FLAG
-- -- -- -- |	// 0x2C |   uint    |   GPA
-- -- -- -- |	// 0x30 |   uint    |   PC to return to
-- -- -- -- |	// 0x34 |   uint    |   EXE to return to
-- -- -- -- |	// 0x38 |   uint    |   destination register contents after last cycle (if RETRY)
-- -- -- -- |	// 0x3C |   uint    |   destination register location on stack (if RETRY)
-- -- -- -- |	//                          i.e., where to write contents (DMEM10) to
-- -- -- -- |	//==============================
-- -- -- -- |	
00 00 05 00 |	WBASE DMEM00 //we have FLAG, safe to overwrite //TODO remove 
00 00 05 02 |	WOFST DMEM04
-- -- -- -- |	
-- -- -- -- |	//dump registers to kernel's stack
-- -- -- -- |	//TODO need to dump LINK as well (and update mapping in Processor3.cs)
00 00 05 04 |	IADF WBASE
00 00 05 06 |	SKIP PC
00 00 05 08 |	::KERNEL_STACK
00 00 05 0C |	00 WOFST
00 00 05 0E |	GPA WMEM
00 00 05 10 |	04 WOFST
00 00 05 12 |	GPB WMEM
00 00 05 14 |	08 WOFST
00 00 05 16 |	GPC WMEM
00 00 05 18 |	0C WOFST
00 00 05 1A |	GPD WMEM
00 00 05 1C |	10 WOFST
00 00 05 1E |	GPE WMEM
00 00 05 20 |	14 WOFST
00 00 05 22 |	GPF WMEM
00 00 05 24 |	18 WOFST
00 00 05 26 |	GPG WMEM
00 00 05 28 |	1C WOFST
00 00 05 2A |	GPH WMEM
-- -- -- -- |	
00 00 05 2C |	20 WOFST
00 00 05 2E |	COMPA WMEM
00 00 05 30 |	24 WOFST
00 00 05 32 |	COMPB WMEM
00 00 05 34 |	28 WOFST
00 00 05 36 |	RBASE WMEM
00 00 05 38 |	2C WOFST
00 00 05 3A |	ROFST WMEM
00 00 05 3C |	30 WOFST
00 00 05 3E |	ALUM WMEM
00 00 05 40 |	34 WOFST
00 00 05 42 |	ALUA WMEM
00 00 05 44 |	38 WOFST
00 00 05 46 |	ALUB WMEM
00 00 05 48 |	3C WOFST
00 00 05 4A |	FPUM WMEM
00 00 05 4C |	40 WOFST
00 00 05 4E |	FPUA WMEM
00 00 05 50 |	44 WOFST
00 00 05 52 |	FPUB WMEM
00 00 05 54 |	48 WOFST
00 00 05 56 |	DMEM00 WMEM
00 00 05 58 |	4C WOFST
00 00 05 5A |	DMEM04 WMEM
00 00 05 5C |	50 WOFST
-- -- -- -- |	
-- -- -- -- |	FRAME_START
-- -- -- -- |	//=========================
-- -- -- -- |	// interrupt handler stack layout / local variables
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   FLAG
-- -- -- -- |	// 0x04 |   uint    |   faulted PTE
-- -- -- -- |	// 0x08 |   uint    |   faulted virtual address
-- -- -- -- |	// 0x0C |   uint    |   faulted PTE disk block
-- -- -- -- |	// 0x10 |   uint    |   virtual page number from faulted virtual address
-- -- -- -- |	// 0x14 |   uint    |   active process ID
-- -- -- -- |	// 0x18 |   uint    |   active process page directory physical page
-- -- -- -- |	// 0x1C |   uint    |   physical page new page is moved into
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	    STACK flag_val 04
-- -- -- -- |	    STACK faulted_pte 04
-- -- -- -- |	    STACK faulted_va 04
-- -- -- -- |	    STACK faulted_pte_block 04
-- -- -- -- |	    STACK faulted_va_vpage_num 04
-- -- -- -- |	    STACK active_process_id 04
-- -- -- -- |	    STACK active_process_page_directory_ppage 04
-- -- -- -- |	    STACK target_ppage 04
-- -- -- -- |	    STACK fetched_pde 04 // possibly different than faulted PTE if the leaf page faulted
-- -- -- -- |	    STACK fetched_pte 04 // retrieved by following the PDE if leaf page faulted
-- -- -- -- |	                            //should be the same as faulted PTE in that case
-- -- -- -- |	    STACK fetched_pde_kpa 04
-- -- -- -- |	    STACK fetched_pte_kpa 04
-- -- -- -- |	
-- -- -- -- |	//add stack frame; registers are dumped to bottom of the stack, so we don't need to save a frame pointer
-- -- -- -- |	//  (specifically because handler runs at the very bottom of the kernel's stack)
-- -- -- -- |	//(just set WBASE to 00 when it's time to retrieve them)
00 00 05 5E |	01 ALUM //add
00 00 05 60 |	WBASE ALUA
00 00 05 62 |	WOFST ALUB
00 00 05 64 |	ALUR WBASE //WBASE = FP == start of first frame on the stack
-- -- -- -- |	    //before this is the dumped contents of the processor before the interrupt
00 00 05 66 |	ISIZE_FRAME WOFST //WOFST = SP == frame size
-- -- -- -- |	
-- -- -- -- |	//store FLAG in local variable
00 00 05 68 |	    WBASE RBASE
00 00 05 6A |	    ISTACK_flag_val ROFST
00 00 05 6C |	    FLAG RMEM
-- -- -- -- |	
-- -- -- -- |	//if RETRY interrupt, we need to restore the destination's contents from the last instruction cache
-- -- -- -- |	//since a faulted read may have wrongfully clobbered that register
-- -- -- -- |	    //determine if this is a RETRY interrupt
00 00 05 6E |	        FLAG ALUA //FLAG to ALU
00 00 05 70 |	        IADF ALUB //RETRY bit mask to ALU
00 00 05 72 |	        SKIP PC
00 00 05 74 |	        10 00 00 00 //RETRY bit mask
00 00 05 78 |	        08 ALUM //AND mode
00 00 05 7A |	        ALUR ALUA //RETRY bit from FLAG (unshifted) to ALU
00 00 05 7C |	        1C ALUB //shift 28 bits right (RETRY bit to LSB position)
00 00 05 7E |	        06 ALUM //right shift mode
00 00 05 80 |	        ALUR COMPA //RETRY bit is 1? to comparator
00 00 05 82 |	        01 COMPB //0b1 to comparator
00 00 05 84 |	        COMPR PC
00 00 05 86 |	        :retry_interrupt
00 00 05 8A |	        :non_retry_interrupt
-- -- -- -- |	
-- -- -- -- |	    @retry_interrupt
-- -- -- -- |	    //this is a RETRY interrupt, we need to restore the clobbered register
-- -- -- -- |	    //the last instruction cache contains the offset (from kernel stack base) where we stored the destination's contents
-- -- -- -- |	    //  (the location we need to repair depends on the instruction that faulted)
-- -- -- -- |	
-- -- -- -- |	    //in some RETRY interrupts, we still don't need to restore the clobbered register
-- -- -- -- |	    //  (ex.: if a page fault occurred during instruction fetch, no register was written)
-- -- -- -- |	    //first, check for that case
00 00 05 8E |	        DMEM3C COMPA //dump location of clobbered register to comparator
00 00 05 90 |	        IADF COMPB
00 00 05 92 |	        SKIP PC
00 00 05 94 |	        FF FF FF FF //sentinel value set by trap to indicate we shouldn't restore
-- -- -- -- |	        //if the sentinel value is set, skip the restoring
00 00 05 98 |	        COMPR PC
00 00 05 9A |	        :retry_interrupt_skip_restore
00 00 05 9E |	        :retry_interrupt_do_restore
-- -- -- -- |	
-- -- -- -- |	    @retry_interrupt_do_restore
-- -- -- -- |	    //we do need to restore the destination's old contents
-- -- -- -- |	    //overwrite our dump of that register with the last instruction cache's dump
-- -- -- -- |	        //TODO this needs to be tested manually
00 00 05 A2 |	        IADF RBASE //base of kernel stack
00 00 05 A4 |	        SKIP PC
00 00 05 A6 |	        ::KERNEL_STACK
00 00 05 AA |	        DMEM3C ROFST //dump location of clobbered register is at DMEM3C
00 00 05 AC |	        DMEM38 RMEM //last instruction cache's dump of the register is DMEM38
-- -- -- -- |	
-- -- -- -- |	@non_retry_interrupt
-- -- -- -- |	@retry_interrupt_skip_restore
-- -- -- -- |	//don't need to restore any register, continue executing
-- -- -- -- |	
-- -- -- -- |	//determine the cause of the interrupt
-- -- -- -- |	    //mask flag to check if interrupt was raised on MMU channel
00 00 05 AE |	    FLAG ALUA
00 00 05 B0 |	    IADF ALUB
00 00 05 B2 |	    SKIP PC
00 00 05 B4 |	    00 00 00 01 //mask for the first channel (MMU)
00 00 05 B8 |	    08 ALUM //AND mode
00 00 05 BA |	    ALUR COMPA
00 00 05 BC |	    00 COMPB //if flag channel is 1, jump to mmu interrupt handler
00 00 05 BE |	    COMPR PC
00 00 05 C0 |	    :non_mmu_interrupt
00 00 05 C4 |	    :mmu_interrupt
-- -- -- -- |	
-- -- -- -- |	@non_mmu_interrupt
-- -- -- -- |	//if interrupt is not from MMU
-- -- -- -- |	    //do nothing if the interrupt is from anywhere besides the MMU
00 00 05 C8 |	    7F FLAG
-- -- -- -- |	
-- -- -- -- |	@mmu_interrupt
-- -- -- -- |	//else interrupt is from MMU
-- -- -- -- |	//retrieve the faulted PTE from the MMU
00 00 05 CA |	    IADF RBASE
00 00 05 CC |	    SKIP PC
00 00 05 CE |	    00 00 10 00 //MMU VA
00 00 05 D2 |	    0C ROFST //0x0C == faulted PTE register offset in MMU address range
00 00 05 D4 |	    RMEM GPA
-- -- -- -- |	
-- -- -- -- |	//retrieve the faulted address from the MMU
00 00 05 D6 |	    10 ROFST //0x10 == faulted VA register offset in MMU address range
00 00 05 D8 |	    RMEM GPB
-- -- -- -- |	
-- -- -- -- |	//store faulted PTE and faulted virtual address in local variables
00 00 05 DA |	    WBASE RBASE
00 00 05 DC |	    ISTACK_faulted_pte ROFST
00 00 05 DE |	    GPA RMEM
00 00 05 E0 |	    ISTACK_faulted_va ROFST
00 00 05 E2 |	    GPB RMEM
-- -- -- -- |	
-- -- -- -- |	//get the active process ID and page directory physical page from kernel memory
00 00 05 E4 |	    00 ROFST
00 00 05 E6 |	    IADF RBASE
00 00 05 E8 |	    SKIP PC
00 00 05 EA |	    ::ACTIVE_PROCESS_ID
00 00 05 EE |	    RMEM GPC
00 00 05 F0 |	    IADF RBASE
00 00 05 F2 |	    SKIP PC
00 00 05 F4 |	    ::ACTIVE_PROCESS_PAGE_DIRECTORY_PHYSICAL_PAGE
00 00 05 F8 |	    RMEM GPD
-- -- -- -- |	
-- -- -- -- |	//store active process ID and page directory physical page in local variables
00 00 05 FA |	    WBASE RBASE
00 00 05 FC |	    ISTACK_active_process_id ROFST
00 00 05 FE |	    GPC RMEM
00 00 06 00 |	    ISTACK_active_process_page_directory_ppage ROFST
00 00 06 02 |	    GPD RMEM
-- -- -- -- |	
-- -- -- -- |	//check PTE protections
-- -- -- -- |	//get them from PTE
00 00 06 04 |	    GPA ALUA //PTE to ALU
00 00 06 06 |	    IADF ALUB //mask to ALU
00 00 06 08 |	    SKIP PC
00 00 06 0A |	    C0 00 00 00 //mask for the RW bits of the PTE
00 00 06 0E |	    08 ALUM //AND mode
-- -- -- -- |	
00 00 06 10 |	    ALUR ALUA //RW bits to ALU
00 00 06 12 |	    1E ALUB //shift 30 bits right
00 00 06 14 |	    06 ALUM //right shift mode
-- -- -- -- |	
-- -- -- -- |	//see which of 00, 01, 10, 11 the RW bits are
00 00 06 16 |	ALUR COMPA
00 00 06 18 |	00 COMPB //0b00
00 00 06 1A |	COMPR PC
00 00 06 1C |	:r0w0
00 00 06 20 |	:_r0w0
-- -- -- -- |	@_r0w0
00 00 06 24 |	01 COMPB //0b01
00 00 06 26 |	COMPR PC
00 00 06 28 |	:r0w1
00 00 06 2C |	:_r0w1
-- -- -- -- |	@_r0w1
00 00 06 30 |	02 COMPB //0b10
00 00 06 32 |	COMPR PC
00 00 06 34 |	:r1w0
00 00 06 38 |	:_r1w0
-- -- -- -- |	@_r1w0
00 00 06 3C |	7F FLAG //halt; RW was 11, no page fault should have occurred
-- -- -- -- |	
-- -- -- -- |	@r0w0
-- -- -- -- |	//not mapped (possibly syscall)
00 00 06 3E |	7F FLAG //TODO for now, just halt
-- -- -- -- |	
-- -- -- -- |	@r1w0
-- -- -- -- |	//page is readable but not writable
-- -- -- -- |	//either a shared page or a clean page
-- -- -- -- |	//page needs to be split or marked as dirty
00 00 06 40 |	7F FLAG //TODO for now, just halt
-- -- -- -- |	
-- -- -- -- |	@r0w1
-- -- -- -- |	//not readable and "writable" indicates the page is mapped but paged out
-- -- -- -- |	//page not resident
-- -- -- -- |	
-- -- -- -- |	//push function address onto stack
00 00 06 42 |	IADF WMEM
00 00 06 44 |	SKIP PC
00 00 06 46 |	::get_open_physical_page
-- -- -- -- |	
00 00 06 4A |	01 ALUM //add mode
00 00 06 4C |	ISIZE_FRAME ALUA //stack frame size
00 00 06 4E |	04 ALUB //add 4 for room for the target address, which we just pushed to the stack
-- -- -- -- |	//TODO theoretically this is known at compile time; add macro for ISIZE_FRAME+X ?
00 00 06 50 |	ALUR WOFST //SP = size of stack frame + 4
-- -- -- -- |	
-- -- -- -- |	//jump to function
00 00 06 52 |	RTRN LINK
00 00 06 54 |	IADN PC
00 00 06 56 |	::FUNC
-- -- -- -- |	
-- -- -- -- |	//result of function call is target physical page number
-- -- -- -- |	//pop result from stack
00 00 06 5A |	    ISIZE_FRAME WOFST //size of stack frame, top of stack
00 00 06 5C |	    WMEM GPH
-- -- -- -- |	//store in local variable
00 00 06 5E |	    WBASE RBASE
00 00 06 60 |	    ISTACK_target_ppage ROFST
00 00 06 62 |	    GPH RMEM
-- -- -- -- |	
-- -- -- -- |	//load page from disk
-- -- -- -- |	//get disk block from PTE
00 00 06 64 |	    GPA ALUA //PTE to ALU
00 00 06 66 |	    IADF ALUB //mask to ALU
00 00 06 68 |	    SKIP PC
00 00 06 6A |	    00 0F FF FF //disk block mask
00 00 06 6E |	    08 ALUM //AND mode
00 00 06 70 |	    ALUR GPE
-- -- -- -- |	//get virtual page / virtual directory number from virtual address
00 00 06 72 |	    GPB ALUA //virtual address to ALU
00 00 06 74 |	    IADF ALUB //mask to ALU
00 00 06 76 |	    SKIP PC
00 00 06 78 |	    FF FF F0 00 //remove physical offset part of virtual address
00 00 06 7C |	    ALUR GPF
-- -- -- -- |	
-- -- -- -- |	//store disk block and virtual page number in local variables
00 00 06 7E |	    WBASE RBASE
00 00 06 80 |	    ISTACK_faulted_pte_block ROFST
00 00 06 82 |	    GPE RMEM
00 00 06 84 |	    ISTACK_faulted_va_vpage_num ROFST
00 00 06 86 |	    GPF RMEM
-- -- -- -- |	
-- -- -- -- |	//load from disk
-- -- -- -- |	    //point RMEM to virtual disk
00 00 06 88 |	        IADF RBASE
00 00 06 8A |	        SKIP PC
00 00 06 8C |	        00 00 10 1C //MMIO starts at VA 1000
-- -- -- -- |	    //tell disk the target physical page (stored in GPH)
00 00 06 90 |	        00 ROFST
00 00 06 92 |	        GPH RMEM
-- -- -- -- |	    //tell disk target disk block (stored in GPE)
00 00 06 94 |	        04 ROFST
00 00 06 96 |	        GPE RMEM
-- -- -- -- |	    //use read mode
00 00 06 98 |	        08 ROFST
00 00 06 9A |	        00 RMEM
-- -- -- -- |	    //initiate transfer from disk to memory
00 00 06 9C |	        0C ROFST
00 00 06 9E |	        01 RMEM
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//update physical page map
-- -- -- -- |	    //point RMEM to physical page map array
00 00 06 A0 |	        IADF RBASE
00 00 06 A2 |	        SKIP PC
00 00 06 A4 |	        ::physical_page_map
-- -- -- -- |	
-- -- -- -- |	    //calculate offset of target physical page entry
00 00 06 A8 |	        02 ALUM //multiply
00 00 06 AA |	        GPH ALUA //target physical page
00 00 06 AC |	        14 ALUB //20 bytes per entry
00 00 06 AE |	        ALUR ROFST //physical page map offset
-- -- -- -- |	
00 00 06 B0 |	    GPC RMEM //set process ID to user process
-- -- -- -- |	
-- -- -- -- |	    //move to next field in entry
00 00 06 B2 |	        01 ALUM //add
00 00 06 B4 |	        ROFST ALUA
00 00 06 B6 |	        04 ALUB
00 00 06 B8 |	        ALUR ROFST
-- -- -- -- |	
00 00 06 BA |	    GPD RMEM //set directory physical page to user directory
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 06 BC |	        ALUR ALUA
00 00 06 BE |	        ALUR ROFST
-- -- -- -- |	        
00 00 06 C0 |	    GPF RMEM //set virtual page/directory number to that of the faulted address
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 06 C2 |	        ALUR ALUA
00 00 06 C4 |	        ALUR ROFST
-- -- -- -- |	
00 00 06 C6 |	    01 RMEM //only one process references this page
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 06 C8 |	        ALUR ALUA
00 00 06 CA |	        ALUR ROFST
-- -- -- -- |	
00 00 06 CC |	    GPE RMEM //store origin disk block as the disk block
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//update process map
-- -- -- -- |	    //point RMEM to process map
00 00 06 CE |	        IADF RBASE
00 00 06 D0 |	        SKIP PC
00 00 06 D2 |	        ::process_map
-- -- -- -- |	
-- -- -- -- |	    //calculate offset of target process entry ((process ID - 1) is index into map)
-- -- -- -- |	        // (16 * (PID - 1)) + 8
00 00 06 D6 |	        03 ALUM //subtract
00 00 06 D8 |	        GPC ALUA //process ID
00 00 06 DA |	        01 ALUB //minus 1
00 00 06 DC |	        ALUR ALUA //ALUA = PID - 1
-- -- -- -- |	
00 00 06 DE |	        10 ALUB //16 byte per entry
00 00 06 E0 |	        02 ALUM //multiply
00 00 06 E2 |	        ALUR ALUA //process entry map offset
00 00 06 E4 |	        08 ALUB //offset into entry for number of resident pages
00 00 06 E6 |	        01 ALUM //add
00 00 06 E8 |	        ALUR ROFST //total offset into process map
-- -- -- -- |	
-- -- -- -- |	    //increment number of resident pages for this process
00 00 06 EA |	        RMEM ALUA
00 00 06 EC |	        01 ALUB
00 00 06 EE |	        ALUR RMEM
-- -- -- -- |	
-- -- -- -- |	//update page table
-- -- -- -- |	//TODO how do we know if we loaded a page table or a leaf page?
-- -- -- -- |	//  if we loaded a leaf page, we need to update the page table
-- -- -- -- |	//  but if we loaded a page table, we need to update the page directory
-- -- -- -- |	//      Use the page table to see which of the PDE/PTE was protected -> caused this fault
-- -- -- -- |	//  traverse the page table: the first PDE/PTE with matching protection bits
-- -- -- -- |	//  was the one that failed
-- -- -- -- |	//      this is true because !R,W always means the page is mapped but not resident.
-- -- -- -- |	//      if we are trying to load a leaf page, it is not possible that the parent table
-- -- -- -- |	//      is !R,W (evicted), because we would have faulted on accessing that table before
-- -- -- -- |	//      we ever knew we needed to bring this leaf page into memory.
-- -- -- -- |	//      therefore, if the PDE is !R,W, we are definitely loading a page table
-- -- -- -- |	//      ...if PDE caused fault: we are loading a page table into memory
-- -- -- -- |	//      ...if PTE caused fault: we are loading a leaf page into memory
-- -- -- -- |	
-- -- -- -- |	//update page table
-- -- -- -- |	// get the PDE (don't just use the faulted PTE; we still don't know if that is a PDE or PTE)
-- -- -- -- |	//  if the PDE was the one that faulted, it should have been !R,W
-- -- -- -- |	//      now the page table it points to is in memory, mark the PDE as R,!W
-- -- -- -- |	//          the page table is write protected because it is clean compared to disk
-- -- -- -- |	//      mark the PDE as !F,!D since the page table is clean and newly loaded
-- -- -- -- |	//          handling this fault does not count as accessing/referencing the newly loaded page table
-- -- -- -- |	//          a subsequent read, or handling a PTE fault, would mark the PDE as referenced, though
-- -- -- -- |	//      update the PDE with the new physical page where the page table was put (local var at 0x1C)
-- -- -- -- |	//      done
-- -- -- -- |	//  if the PDE was not the one that faulted, it should have been R,W
-- -- -- -- |	//      mark the PDE as F,D since we will be updating the page table with the newly loaded leaf page's information
-- -- -- -- |	//          F bit should have been set before MMU faulted on the page anyway, since we read the page table
-- -- -- -- |	//      the PTE should have been the one that faulted; the leaf page was just loaded into memory
-- -- -- -- |	//          the PTE should be !R,W
-- -- -- -- |	//          get the PTE by following the PDE to the page table
-- -- -- -- |	//          set the PTE to R,!W
-- -- -- -- |	//              R because the page is now resident in memory and safe to read
-- -- -- -- |	//              !W because the page is clean compared to disk (it was just loaded)
-- -- -- -- |	//          mark the PTE as !F,!D since the leaf page is clean and newly loaded
-- -- -- -- |	//              F bit will be set when the instruction is retried, but loading the page right now doesn't count as reference
-- -- -- -- |	//          update the PTE with the new physical page where the page table was put (local var at 0x1C)
-- -- -- -- |	//      done
-- -- -- -- |	
-- -- -- -- |	//get PDE
00 00 06 F0 |	    05 ALUM //left shift
00 00 06 F2 |	    GPD ALUA //active process page directory physical page
00 00 06 F4 |	    0C ALUB //12 bits
00 00 06 F6 |	    ALUR GPA //GPA = page directory base address
-- -- -- -- |	
-- -- -- -- |	    //page table number = (virtual address & 0xFFC00000) >> 22
00 00 06 F8 |	    08 ALUM //AND
00 00 06 FA |	    GPB ALUA //virtual address
00 00 06 FC |	    IADF ALUB //mask for first 12 bits
00 00 06 FE |	    SKIP PC
00 00 07 00 |	    FF C0 00 00
-- -- -- -- |	
00 00 07 04 |	    ALUR ALUA
00 00 07 06 |	    06 ALUM //right shift
00 00 07 08 |	    14 ALUB //20 bits (page number is given by shifting 22 bits, but offset into page table is page number * 4, so shift left 2 bits)
-- -- -- -- |	
00 00 07 0A |	    ALUR ALUB
00 00 07 0C |	    GPA ALUA
00 00 07 0E |	    07 ALUM //OR
-- -- -- -- |	        //TODO setting OR then AND? probably do the same thing in this case
-- -- -- -- |	        // probably need to swap the next two instructions: use OR, retrieve result, then set AND
00 00 07 10 |	    01 ALUM //add
00 00 07 12 |	    ALUR ALUA //page directory entry physical address
00 00 07 14 |	    IADF ALUB //add 0x00 3F 00 00 to get kernel virtual address of physical address
00 00 07 16 |	    SKIP PC
00 00 07 18 |	    00 3F 00 00
-- -- -- -- |	
-- -- -- -- |	    //save kernel's VA of the PDE in local variable; we'll need to write the updated PDE back later
00 00 07 1C |	    WBASE RBASE
00 00 07 1E |	    ISTACK_fetched_pde_kpa ROFST
00 00 07 20 |	    ALUR RMEM
-- -- -- -- |	
-- -- -- -- |	    //set RBASE to point to the PDE for the faulted address (may or may not be the PDE/PTE that faulted)
00 00 07 22 |	    ALUR RBASE
00 00 07 24 |	    00 ROFST
-- -- -- -- |	
-- -- -- -- |	//check if PDE or PTE faulted
-- -- -- -- |	//  PDE faulted if the PDE is !R,W
-- -- -- -- |	//  else PTE faulted (if PTE faulted, PDE is necessarily R,W, else it would have faulted first)
-- -- -- -- |	    //extract RW bits from PDE
00 00 07 26 |	        RMEM ALUA //PDE to ALU
-- -- -- -- |	
-- -- -- -- |	            //store PDE in local variable for later
00 00 07 28 |	            WBASE RBASE
00 00 07 2A |	            ISTACK_fetched_pde ROFST
00 00 07 2C |	            ALUA RMEM
-- -- -- -- |	
00 00 07 2E |	        IADF ALUB //protection mask to ALU
00 00 07 30 |	        SKIP PC
00 00 07 32 |	        C0 00 00 00 //mask for the RW bits of the PDE
00 00 07 36 |	        08 ALUM //AND mode
-- -- -- -- |	
00 00 07 38 |	        ALUR ALUA //RW bits to ALU
00 00 07 3A |	        1E ALUB //shift 30 bits right
00 00 07 3C |	        06 ALUM //right shift mode
-- -- -- -- |	
-- -- -- -- |	    //compare PDE RW bits to !R,W (0x01)
00 00 07 3E |	        ALUR COMPA //RW bits to comparator
00 00 07 40 |	        01 COMPB //!R,W (0x01) to comparator
00 00 07 42 |	        COMPR PC
00 00 07 44 |	        :table_caused_r0w1 //the PDE faulted, so we just loaded a page table into memory
00 00 07 48 |	        :leaf_caused_r0w1 //the PTE faulted, so we just loaded a leaf page into memory
-- -- -- -- |	
-- -- -- -- |	@table_caused_r0w1 //IF CLAUSE (PDE faulted)
-- -- -- -- |	//if PDE faulted, we just loaded a page table in; update the PDE
-- -- -- -- |	//  update the PDE to be R,!W,!F,!D
00 00 07 4C |	    7F FLAG // TODO implement this
-- -- -- -- |	
-- -- -- -- |	// skip else clause
00 00 07 4E |	IADN PC
00 00 07 50 |	:conclude_r0w1
-- -- -- -- |	
-- -- -- -- |	@leaf_caused_r0w1 //ELSE CLAUSE (PTE faulted)
-- -- -- -- |	//else if PTE faulted, we just loaded a leaf page in; update the PDE and PTE
-- -- -- -- |	    //fetch the PTE through the PDE
-- -- -- -- |	        //we know the page table is resident, since the PDE didn't fault
-- -- -- -- |	        //therefore PDE holds the physical page of the PTE
-- -- -- -- |	
-- -- -- -- |	        //page table base address == (PDE & 0x000FFFFF) << 12
00 00 07 54 |	        WBASE RBASE
00 00 07 56 |	        ISTACK_fetched_pde ROFST
00 00 07 58 |	        RMEM ALUA //PDE to ALU
00 00 07 5A |	        IADF ALUB //mask to ALU
00 00 07 5C |	        SKIP PC
00 00 07 5E |	        00 0F FF FF //physical page mask
00 00 07 62 |	        08 ALUM //AND mode
-- -- -- -- |	
00 00 07 64 |	        ALUR ALUA //physical page number of page table
00 00 07 66 |	        0C ALUB //12 bits
00 00 07 68 |	        05 ALUM //left shift
00 00 07 6A |	        ALUR GPA //GPA = page table base address
-- -- -- -- |	
-- -- -- -- |	        //page number = (virtual address & 0x003FF000) >> 12
-- -- -- -- |	            // PTEs are 4 bytes, so address is (table addr + (page number * 4))
-- -- -- -- |	            // skip the *4 by shifting only 10 bits instead of 12
-- -- -- -- |	        //(virtual address & 0x003FF000) >> 10
00 00 07 6C |	        ISTACK_faulted_va ROFST
00 00 07 6E |	        RMEM ALUA //VA to ALU
00 00 07 70 |	        IADF ALUB //mask to ALU
00 00 07 72 |	        SKIP PC
00 00 07 74 |	        00 3F F0 00 //page number mask
00 00 07 78 |	        08 ALUM //AND
-- -- -- -- |	        
00 00 07 7A |	        ALUR ALUA // page number of PTE (from PDE, unshifted)
00 00 07 7C |	        06 ALUM //right shift
00 00 07 7E |	        0A ALUB //10 bits
-- -- -- -- |	
00 00 07 80 |	        ALUR ALUB //page number * 4
00 00 07 82 |	        GPA ALUA //page table base address
00 00 07 84 |	        07 ALUM //OR
-- -- -- -- |	
00 00 07 86 |	        ALUR ALUA //page table entry physical address to ALU
00 00 07 88 |	        IADF ALUB //add 0x00 3F 00 00 to get kernel virtual address of any physical address
00 00 07 8A |	        SKIP PC
00 00 07 8C |	        00 3F 00 00 //PA->kernel VA offset
00 00 07 90 |	        01 ALUM //ADD
00 00 07 92 |	        ALUR RBASE //PTE address in kernel VA
00 00 07 94 |	        00 ROFST //RMEM points to PTE
-- -- -- -- |	
00 00 07 96 |	        RMEM GPB //save the PTE somewhere
00 00 07 98 |	        WBASE RBASE
00 00 07 9A |	        ISTACK_fetched_pte ROFST
00 00 07 9C |	        GPB RMEM //store the fetched PTE in local variable
-- -- -- -- |	
00 00 07 9E |	        ISTACK_fetched_pte_kpa ROFST
00 00 07 A0 |	        ALUR RMEM //store kernel's VA of PTE in local variable; we'll need to write the updated PTE back
-- -- -- -- |	
-- -- -- -- |	    //assert that the PTE is !R,W
-- -- -- -- |	        //get the protection bits
00 00 07 A2 |	            GPB ALUA //PTE to ALU
00 00 07 A4 |	            IADF ALUB //mask to ALU
00 00 07 A6 |	            SKIP PC
00 00 07 A8 |	            C0 00 00 00 //mask for the RW bits of the PTE
00 00 07 AC |	            08 ALUM //AND
-- -- -- -- |	
00 00 07 AE |	            ALUR ALUA //RW bits to ALU
00 00 07 B0 |	            1E ALUB //shift 30 bits right
00 00 07 B2 |	            06 ALUM //right shift mode
-- -- -- -- |	
-- -- -- -- |	        //compare PTE RW bits to !R,W (0x01)
00 00 07 B4 |	            ALUR COMPA //RW bits to comparator
00 00 07 B6 |	            01 COMPB //!R,W (0x01)
00 00 07 B8 |	            COMPR PC
00 00 07 BA |	            :assertion_passed_faulted_pte_not_0rw1
00 00 07 BE |	            :assertion_failed_faulted_pte_not_0rw1
-- -- -- -- |	
-- -- -- -- |	        @assertion_failed_faulted_pte_not_0rw1
-- -- -- -- |	        //if these are not the protection bits, neither the PDE nor PTE faulted?
-- -- -- -- |	        //we are in the !R,W branch, so one of PDE and PTE should have !R,W
-- -- -- -- |	        //since neither meet that criteria, HALT; PANIC
00 00 07 C2 |	            7F FLAG
-- -- -- -- |	
-- -- -- -- |	    @assertion_passed_faulted_pte_not_0rw1
-- -- -- -- |	    //update the PDE to be F,D
00 00 07 C4 |	        ISTACK_fetched_pde ROFST
00 00 07 C6 |	        RMEM GPC //GPC = PDE we need to update
-- -- -- -- |	        //GPB already holds PTE we need to update
-- -- -- -- |	
00 00 07 C8 |	        GPC ALUA //PDE to ALU
00 00 07 CA |	        IADF ALUB //mask to ALU
00 00 07 CC |	        SKIP PC
00 00 07 CE |	        30 00 00 00 //F,D mask
00 00 07 D2 |	        07 ALUM //OR mode
-- -- -- -- |	
-- -- -- -- |	    //write updated PDE back to page directory
00 00 07 D4 |	        ISTACK_fetched_pde_kpa ROFST
00 00 07 D6 |	        RMEM RBASE
00 00 07 D8 |	        00 ROFST
00 00 07 DA |	        ALUR RMEM
-- -- -- -- |	
-- -- -- -- |	    //update the PTE to be R,!W,!F,!D
00 00 07 DC |	        GPB ALUA //PTE to ALU
00 00 07 DE |	        IADF ALUB //mask to ALU
00 00 07 E0 |	        SKIP PC
00 00 07 E2 |	        80 00 00 00 //R,!W,!F,!D mask
-- -- -- -- |	
-- -- -- -- |	    //update the PTE with the physical page where the page now lives
-- -- -- -- |	    //  we're replacing the disk block in the PTE, but we already saved it
-- -- -- -- |	    //  in the kernel's physical page map
-- -- -- -- |	
-- -- -- -- |	        // erase the disk block part of the PTE
00 00 07 E6 |	            ALUR ALUA //updated PTE to ALU
00 00 07 E8 |	            IADF ALUB //mask to ALU
00 00 07 EA |	            SKIP PC
00 00 07 EC |	            FF F0 00 00 //disk block mask
00 00 07 F0 |	            08 ALUM //AND mode
-- -- -- -- |	
00 00 07 F2 |	            ALUR ALUA //PTE with disk block removed to ALU
00 00 07 F4 |	            WBASE RBASE
00 00 07 F6 |	            ISTACK_target_ppage ROFST
00 00 07 F8 |	            RMEM ALUB //physical page where page now resides to ALU
00 00 07 FA |	            07 ALUM //OR mode
-- -- -- -- |	
-- -- -- -- |	        //write updated PTE back to page table
00 00 07 FC |	            ISTACK_fetched_pte_kpa ROFST
00 00 07 FE |	            RMEM RBASE
00 00 08 00 |	            00 ROFST
00 00 08 02 |	            ALUR RMEM
-- -- -- -- |	        //done; return from interrupt handler
-- -- -- -- |	
-- -- -- -- |	@conclude_r0w1
-- -- -- -- |	//return from interrupt
-- -- -- -- |	//TODO implement this
00 00 08 04 |	BREAK
00 00 08 06 |	00 RBASE
00 00 08 08 |	33 ROFST
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//nothing left
00 00 08 0A |	02 FPUM
00 00 08 0C |	11 FPUA
00 00 08 0E |	22 FPUB
00 00 08 10 |	FPUR GPC
00 00 08 12 |	7F FLAG
-- -- -- -- |	// end interrupt handler
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//TODO move this to where we determine this is a RETRY interrupt; it can happen at any time
-- -- -- -- |	// 00 WBASE
-- -- -- -- |	// dmem_dest_offset WOFST
-- -- -- -- |	// dmem_contents WMEM
-- -- -- -- |	
-- -- -- -- |	// DMEM00 WBASE
-- -- -- -- |	// DMEM04 WOFST
-- -- -- -- |	// DMEM08 PC
-- -- -- -- |	//TODO to ensure the MMU breakpoint isn't triggered by any reads from DMEM,
-- -- -- -- |	//  need to add delay to MMU breakpoint
-- -- -- -- |	
-- -- -- -- |	FRAME_END
-- -- -- -- |	
-- -- -- -- |	//=========================================================================
-- -- -- -- |	// [function] get_open_physical_page | void TODO: this is not void
-- -- -- -- |	//=========================================================================
-- -- -- -- |	@@get_open_physical_page
-- -- -- -- |	//returns physical page number that is available for incoming page
-- -- -- -- |	//may or may not result in page eviction
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//calculate address where return value should be stored
00 00 08 14 |	    03 ALUM //subtract
00 00 08 16 |	    WBASE ALUA //original FP
00 00 08 18 |	    54 ALUB // -84
00 00 08 1A |	    ALUR GPH //GPH = result address = FP - 84
-- -- -- -- |	
-- -- -- -- |	//look for open pages, which we can use without evicting anything
-- -- -- -- |	//open pages have a process ID of 0
-- -- -- -- |	
-- -- -- -- |	//iterate over physical page map
-- -- -- -- |	    //point RMEM to physical page map array
00 00 08 1C |	        IADF RBASE
00 00 08 1E |	        SKIP PC
00 00 08 20 |	        ::physical_page_map
00 00 08 24 |	        00 ROFST
-- -- -- -- |	
00 00 08 26 |	    00 GPA //GPA = index
00 00 08 28 |	    10 GPB //GPB = max_index
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop
-- -- -- -- |	    //check if we're at the end of the loop (index == 16?)
00 00 08 2A |	        GPA COMPA
00 00 08 2C |	        GPB COMPB
00 00 08 2E |	        COMPR PC
00 00 08 30 |	        :open_page_loop_end
00 00 08 34 |	        :open_page_loop_go
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop_go
-- -- -- -- |	    //calculate offset from index
00 00 08 38 |	        02 ALUM //multiply mode
00 00 08 3A |	        GPA ALUA // ALUA = index
00 00 08 3C |	        14 ALUB //20 bytes per entry
00 00 08 3E |	        ALUR ROFST
-- -- -- -- |	
-- -- -- -- |	    //read process ID (offset 0)
00 00 08 40 |	    RMEM GPC //GPC = process id
-- -- -- -- |	
-- -- -- -- |	    //process id == 0?
00 00 08 42 |	        GPC COMPA
00 00 08 44 |	        00 COMPB
00 00 08 46 |	        COMPR PC
00 00 08 48 |	        :open_page_proc_id_0
00 00 08 4C |	        :open_page_loop_next
-- -- -- -- |	    
-- -- -- -- |	    @open_page_proc_id_0
-- -- -- -- |	    // found an open page
-- -- -- -- |	    // return the index as the open physical page
00 00 08 50 |	        WBASE ALUA //store FP somewhere
00 00 08 52 |	        GPH WBASE //point WMEM to the result address
00 00 08 54 |	        00 WOFST
00 00 08 56 |	        GPA WMEM //result = index into physical page map
00 00 08 58 |	        ALUA WBASE //restore FP
00 00 08 5A |	        LINK PC //return
-- -- -- -- |	
-- -- -- -- |	    
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop_next
-- -- -- -- |	    //increment index
00 00 08 5C |	        01 ALUM //add mode
00 00 08 5E |	        GPA ALUA
00 00 08 60 |	        01 ALUB
00 00 08 62 |	        ALUR GPA //index += 1
-- -- -- -- |	    //go to start of loop
00 00 08 64 |	    IADN PC
00 00 08 66 |	    :open_page_loop
-- -- -- -- |	
-- -- -- -- |	    //TODO implement this
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	@open_page_loop_end
-- -- -- -- |	//no open pages
00 00 08 6A |	BREAK
-- -- -- -- |	
-- -- -- -- |	//      TODO important insight:
-- -- -- -- |	//      An evictable page is one where no other non-empty page mapping entry has a "directory physical page" that
-- -- -- -- |	//      matches the evictable page's physical page (this is true of all leaf pages, all page tables with
-- -- -- -- |	//      no child pages in memory, and all page directories with no child tables in memory -- except page
-- -- -- -- |	//      directories point to themselves, so never count self reference)
-- -- -- -- |	//      TODO the above is only true if leaf pages point to their page tables; right now, the "directory physical page"
-- -- -- -- |	//      variable points to the owning process's page directory
-- -- -- -- |	//          Why is it set up that way? To make it easy to see if a process has any non-directory tables or pages in memory?
-- -- -- -- |	//          It should be possible to find the owning process of any page mapping entry by following the "directory physical page"
-- -- -- -- |	//          pointer until it references itself (only true of directories), which is at most 2 steps (2 for leafs, 1 for tables)
-- -- -- -- |	//          The process descriptor in the process map also has the number of resident pages
-- -- -- -- |	
-- -- -- -- |	//TODO implement this
00 00 08 6C |	00 RBASE
00 00 08 6E |	00 ROFST
00 00 08 70 |	7F RMEM
-- -- -- -- |	
-- -- -- -- |	//return
00 00 08 72 |	LINK PC
