-- -- -- -- |	//=========================================================================
-- -- -- -- |	// kernel entry point
-- -- -- -- |	//=========================================================================
-- -- -- -- |	
-- -- -- -- |	// PC is at 0x08 when MMU is enabled, so these won't be executed
00 00 00 00 |	00 00
00 00 00 02 |	00 00
00 00 00 04 |	00 00
-- -- -- -- |	
-- -- -- -- |	//kernel entry point; MMU enabled, we're in VA now
-- -- -- -- |	
-- -- -- -- |	//set the MMU VA break point
00 00 00 06 |	IADF WBASE
00 00 00 08 |	SKIP PC
00 00 00 0A |	00 00 10 00 //MMIO base address (in VA)
00 00 00 0E |	08 WOFST //breakpoint register
00 00 00 10 |	00 WMEM //breakpoint at 0
-- -- -- -- |	
-- -- -- -- |	//enable the breakpoint
00 00 00 12 |	14 WOFST //breakpoint enabled register
00 00 00 14 |	01 WMEM //non-zero -> enabled
-- -- -- -- |	
00 00 00 16 |	00 RBASE
00 00 00 18 |	00 ROFST
-- -- -- -- |	
-- -- -- -- |	//jump to 0 in user space
00 00 00 1A |	00 PC
-- -- -- -- |	//=========================================================================
-- -- -- -- |	// interrupt handler
-- -- -- -- |	//=========================================================================
-- -- -- -- |	
-- -- -- -- |	//Fill to place the interrupt handler code at the correct location
-- -- -- -- |	    //TODO the address of the interrupt handler is currently hardcoded in the simulation environment
-- -- -- -- |	    //interrupt_handler_address in Processor class
00 00 00 1C |	FILL20
00 00 00 20 |	WBASE DMEM00
00 00 00 22 |	WOFST DMEM04
-- -- -- -- |	
-- -- -- -- |	//dump registers to kernel's stack
00 00 00 24 |	IADF WBASE
00 00 00 26 |	SKIP PC
00 00 00 28 |	::KERNEL_STACK
00 00 00 2C |	00 WOFST
00 00 00 2E |	GPA WMEM
00 00 00 30 |	04 WOFST
00 00 00 32 |	GPB WMEM
00 00 00 34 |	08 WOFST
00 00 00 36 |	GPC WMEM
00 00 00 38 |	0C WOFST
00 00 00 3A |	GPD WMEM
00 00 00 3C |	10 WOFST
00 00 00 3E |	GPE WMEM
00 00 00 40 |	14 WOFST
00 00 00 42 |	GPF WMEM
00 00 00 44 |	18 WOFST
00 00 00 46 |	GPG WMEM
00 00 00 48 |	1C WOFST
00 00 00 4A |	GPH WMEM
-- -- -- -- |	
00 00 00 4C |	20 WOFST
00 00 00 4E |	COMPA WMEM
00 00 00 50 |	24 WOFST
00 00 00 52 |	COMPB WMEM
00 00 00 54 |	28 WOFST
00 00 00 56 |	RBASE WMEM
00 00 00 58 |	2C WOFST
00 00 00 5A |	ROFST WMEM
00 00 00 5C |	30 WOFST
00 00 00 5E |	ALUM WMEM
00 00 00 60 |	34 WOFST
00 00 00 62 |	ALUA WMEM
00 00 00 64 |	38 WOFST
00 00 00 66 |	ALUB WMEM
00 00 00 68 |	3C WOFST
00 00 00 6A |	FPUM WMEM
00 00 00 6C |	40 WOFST
00 00 00 6E |	FPUA WMEM
00 00 00 70 |	44 WOFST
00 00 00 72 |	FPUB WMEM
00 00 00 74 |	48 WOFST
00 00 00 76 |	DMEM00 WMEM
00 00 00 78 |	4C WOFST
00 00 00 7A |	DMEM04 WMEM
00 00 00 7C |	50 WOFST
-- -- -- -- |	
-- -- -- -- |	//=========================
-- -- -- -- |	// interrupt handler stack layout / local variables
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   FLAG
-- -- -- -- |	// 0x04 |   uint    |   faulted PTE
-- -- -- -- |	// 0x08 |   uint    |   faulted virtual address
-- -- -- -- |	// 0x0C |   uint    |   faulted PTE disk block
-- -- -- -- |	// 0x10 |   uint    |   virtual page number from faulted virtual address
-- -- -- -- |	// 0x14 |   uint    |   active process ID
-- -- -- -- |	// 0x18 |   uint    |   active process page directory physical page
-- -- -- -- |	// 0x1C |   uint    |   physical page new page is moved into
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	//add stack frame; registers are dumped to bottom of the stack, so we don't need to save a frame pointer
-- -- -- -- |	//(just set WBASE to 00 when it's time to retrieve them)
00 00 00 7E |	01 ALUM //add
00 00 00 80 |	WBASE ALUA
00 00 00 82 |	WOFST ALUB
00 00 00 84 |	ALUR WBASE
00 00 00 86 |	20 WOFST //20 == size of stack frame, described above
-- -- -- -- |	
-- -- -- -- |	//store FLAG in local variable
00 00 00 88 |	    WBASE RBASE
00 00 00 8A |	    00 ROFST //FLAG local variable address (from stack layout)
00 00 00 8C |	    FLAG RMEM
-- -- -- -- |	
-- -- -- -- |	//determine the cause of the interrupt
-- -- -- -- |	    //mask flag to check if interrupt was raised on MMU channel
00 00 00 8E |	    FLAG ALUA
00 00 00 90 |	    IADF ALUB
00 00 00 92 |	    SKIP PC
00 00 00 94 |	    00 00 00 01 //mask for the first channel (MMU)
00 00 00 98 |	    08 ALUM //AND mode
00 00 00 9A |	    ALUR COMPA
00 00 00 9C |	    00 COMPB //if flag channel is 1, jump to mmu interrupt handler
00 00 00 9E |	    COMPR PC
00 00 00 A0 |	    :non_mmu_interrupt
00 00 00 A4 |	    :mmu_interrupt
-- -- -- -- |	
-- -- -- -- |	@non_mmu_interrupt
-- -- -- -- |	//if interrupt is not from MMU
-- -- -- -- |	    //do nothing if the interrupt is from anywhere besides the MMU
00 00 00 A8 |	    7F FLAG
-- -- -- -- |	
-- -- -- -- |	@mmu_interrupt
-- -- -- -- |	//else interrupt is from MMU
-- -- -- -- |	//retrieve the faulted PTE from the MMU
00 00 00 AA |	    IADF RBASE
00 00 00 AC |	    SKIP PC
00 00 00 AE |	    00 00 10 00
00 00 00 B2 |	    0C ROFST
00 00 00 B4 |	    RMEM GPA
-- -- -- -- |	
-- -- -- -- |	//retrieve the faulted address from the MMU
00 00 00 B6 |	    10 ROFST
00 00 00 B8 |	    RMEM GPB
-- -- -- -- |	
-- -- -- -- |	//store faulted PTE and faulted virtual address in local variables
00 00 00 BA |	    WBASE RBASE
00 00 00 BC |	    04 ROFST
00 00 00 BE |	    GPA RMEM
00 00 00 C0 |	    08 ROFST
00 00 00 C2 |	    GPB RMEM
-- -- -- -- |	
-- -- -- -- |	//get the active process ID and page directory physical page from kernel memory
00 00 00 C4 |	    00 ROFST
00 00 00 C6 |	    IADF RBASE
00 00 00 C8 |	    SKIP PC
00 00 00 CA |	    ::ACTIVE_PROCESS_ID
00 00 00 CE |	    RMEM GPC
00 00 00 D0 |	    IADF RBASE
00 00 00 D2 |	    SKIP PC
00 00 00 D4 |	    ::ACTIVE_PROCESS_PAGE_DIRECTORY_PHYSICAL_PAGE
00 00 00 D8 |	    RMEM GPD
-- -- -- -- |	
-- -- -- -- |	//store active process ID and page directory physical page in local variables
00 00 00 DA |	    WBASE RBASE
00 00 00 DC |	    14 ROFST
00 00 00 DE |	    GPC RMEM
00 00 00 E0 |	    18 ROFST
00 00 00 E2 |	    GPD RMEM
-- -- -- -- |	
-- -- -- -- |	//check PTE protections
-- -- -- -- |	//get them from PTE
00 00 00 E4 |	    GPA ALUA //PTE to ALU
00 00 00 E6 |	    IADF ALUB //mask to ALU
00 00 00 E8 |	    SKIP PC
00 00 00 EA |	    C0 00 00 00 //mask for the RW bits of the PTE
00 00 00 EE |	    08 ALUM //AND mode
-- -- -- -- |	
00 00 00 F0 |	    ALUR ALUA //RW bits to ALU
00 00 00 F2 |	    1E ALUB //shift 30 bits right
00 00 00 F4 |	    06 ALUM //right shift mode
-- -- -- -- |	
-- -- -- -- |	//see which of 00, 01, 10, 11 the RW bits are
00 00 00 F6 |	ALUR COMPA
00 00 00 F8 |	00 COMPB
00 00 00 FA |	COMPR PC
00 00 00 FC |	:r0w0
00 00 01 00 |	:_r0w0
-- -- -- -- |	@_r0w0
00 00 01 04 |	01 COMPB
00 00 01 06 |	COMPR PC
00 00 01 08 |	:r0w1
00 00 01 0C |	:_r0w1
-- -- -- -- |	@_r0w1
00 00 01 10 |	02 COMPB
00 00 01 12 |	COMPR PC
00 00 01 14 |	:r1w0
00 00 01 18 |	:_r1w0
-- -- -- -- |	@_r1w0
00 00 01 1C |	7F FLAG //halt; RW was 11, no page fault should have occurred
-- -- -- -- |	
-- -- -- -- |	@r0w0
-- -- -- -- |	//not mapped (possibly syscall)
00 00 01 1E |	7F FLAG //TODO for now, just halt
-- -- -- -- |	
-- -- -- -- |	@r1w0
-- -- -- -- |	//page is readable but not writable
-- -- -- -- |	//either a shared page or a clean page
-- -- -- -- |	//page needs to be split or marked as dirty
00 00 01 20 |	7F FLAG //TODO for now, just halt
-- -- -- -- |	
-- -- -- -- |	@r0w1
-- -- -- -- |	//not readable and "writable" indicates the page is mapped but paged out
-- -- -- -- |	//page not resident
-- -- -- -- |	
-- -- -- -- |	//push function address onto stack
00 00 01 22 |	IADF WMEM
00 00 01 24 |	SKIP PC
00 00 01 26 |	::get_open_physical_page
00 00 01 2A |	24 WOFST //size of stack frame + 4
00 00 01 2C |	RTRN LINK
00 00 01 2E |	IADN PC
00 00 01 30 |	::FUNC
-- -- -- -- |	
-- -- -- -- |	//result of function call is target physical page number
-- -- -- -- |	//pop result from stack
00 00 01 34 |	    20 WOFST //20 == size of stack frame, top of stack
00 00 01 36 |	    WMEM GPH
-- -- -- -- |	//store in local variable
-- -- -- -- |	// ...TODO? ^
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//load page from disk
-- -- -- -- |	//get disk block from PTE
00 00 01 38 |	    GPA ALUA //PTE to ALU
00 00 01 3A |	    IADF ALUB //mask to ALU
00 00 01 3C |	    SKIP PC
00 00 01 3E |	    00 0F FF FF
00 00 01 42 |	    08 ALUM //AND mode
00 00 01 44 |	    ALUR GPE
-- -- -- -- |	//get virtual page / virtual directory number from virtual address
00 00 01 46 |	    GPB ALUA //virtual address to ALU
00 00 01 48 |	    IADF ALUB //mask to ALU
00 00 01 4A |	    SKIP PC
00 00 01 4C |	    FF FF F0 00 //remove physical offset part of virtual address
00 00 01 50 |	    ALUR GPF
-- -- -- -- |	
-- -- -- -- |	//store disk block and virtual page number in local variables
00 00 01 52 |	    WBASE RBASE
00 00 01 54 |	    0C ROFST
00 00 01 56 |	    GPE RMEM
00 00 01 58 |	    10 ROFST
00 00 01 5A |	    GPF RMEM
-- -- -- -- |	
-- -- -- -- |	//load from disk
-- -- -- -- |	    //point RMEM to virtual disk
00 00 01 5C |	        IADF RBASE
00 00 01 5E |	        SKIP PC
00 00 01 60 |	        00 00 10 1C //MMIO starts at VA 1000
-- -- -- -- |	    //tell disk the target physical page (stored in GPH)
00 00 01 64 |	        00 ROFST
00 00 01 66 |	        GPH RMEM
-- -- -- -- |	    //tell disk target disk block (stored in GPE)
00 00 01 68 |	        04 ROFST
00 00 01 6A |	        GPE RMEM
-- -- -- -- |	    //use read mode
00 00 01 6C |	        08 ROFST
00 00 01 6E |	        00 RMEM
-- -- -- -- |	    //initiate transfer from disk to memory
00 00 01 70 |	        0C ROFST
00 00 01 72 |	        01 RMEM
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//update physical page map
-- -- -- -- |	    //point RMEM to physical page map array
00 00 01 74 |	        IADF RBASE
00 00 01 76 |	        SKIP PC
00 00 01 78 |	        ::physical_page_map
-- -- -- -- |	
-- -- -- -- |	    //calculate offset of target physical page entry
00 00 01 7C |	        02 ALUM //multiply
00 00 01 7E |	        GPH ALUA //target physical page
00 00 01 80 |	        14 ALUB //20 bytes per entry
00 00 01 82 |	        ALUR ROFST //physical page map offset
-- -- -- -- |	
00 00 01 84 |	    GPC RMEM //set process ID to user process
-- -- -- -- |	
-- -- -- -- |	    //move to next field in entry
00 00 01 86 |	        01 ALUM //add
00 00 01 88 |	        ROFST ALUA
00 00 01 8A |	        04 ALUB
00 00 01 8C |	        ALUR ROFST
-- -- -- -- |	
00 00 01 8E |	    GPD RMEM //set directory physical page to user directory
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 01 90 |	        ALUR ALUA
00 00 01 92 |	        ALUR ROFST
-- -- -- -- |	        
00 00 01 94 |	    GPF RMEM //set virtual page/directory number to that of the faulted address
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 01 96 |	        ALUR ALUA
00 00 01 98 |	        ALUR ROFST
-- -- -- -- |	
00 00 01 9A |	    01 RMEM //only one process references this page
-- -- -- -- |	
-- -- -- -- |	    //move to next field
00 00 01 9C |	        ALUR ALUA
00 00 01 9E |	        ALUR ROFST
-- -- -- -- |	
00 00 01 A0 |	    GPE RMEM //store origin disk block as the disk block
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//update process map
-- -- -- -- |	    //point RMEM to process map
00 00 01 A2 |	        IADF RBASE
00 00 01 A4 |	        SKIP PC
00 00 01 A6 |	        ::process_map
-- -- -- -- |	
-- -- -- -- |	    //calculate offset of target process entry ((process ID - 1) is index into map)
-- -- -- -- |	        // (16 * (PID - 1)) + 8
00 00 01 AA |	        03 ALUM //subtract
00 00 01 AC |	        GPC ALUA //process ID
00 00 01 AE |	        01 ALUB //minus 1
00 00 01 B0 |	        ALUR ALUA //ALUA = PID - 1
-- -- -- -- |	
00 00 01 B2 |	        10 ALUB //16 byte per entry
00 00 01 B4 |	        02 ALUM //multiply
00 00 01 B6 |	        ALUR ALUA //process entry map offset
00 00 01 B8 |	        08 ALUB //offset into entry for number of resident pages
00 00 01 BA |	        01 ALUM //add
00 00 01 BC |	        ALUR ROFST //total offset into process map
-- -- -- -- |	
-- -- -- -- |	    //increment number of resident pages for this process
00 00 01 BE |	        RMEM ALUA
00 00 01 C0 |	        01 ALUB
00 00 01 C2 |	        ALUR RMEM
-- -- -- -- |	
-- -- -- -- |	//update page table
-- -- -- -- |	//TODO how do we know if we loaded a page table or a leaf page?
-- -- -- -- |	//  if we loaded a leaf page, we need to update the page table
-- -- -- -- |	//  but if we loaded a page table, we need to update the page directory
-- -- -- -- |	//      Use the page table to see which of the PDE/PTE was protected -> caused this fault
-- -- -- -- |	//  traverse the page table: the first PDE/PTE with matching protection bits
-- -- -- -- |	//  was the one that failed
-- -- -- -- |	//      this is true because !R,W always means the page is mapped but not resident.
-- -- -- -- |	//      if we are trying to load a leaf page, it is not possible that the parent table
-- -- -- -- |	//      is !R,W (evicted), because we would have faulted on accessing that table before
-- -- -- -- |	//      we ever knew we needed to bring this leaf page into memory.
-- -- -- -- |	//      therefore, if the PDE is !R,W, we are definitely loading a page table
-- -- -- -- |	//      ...if PDE caused fault: we are loading a page table into memory
-- -- -- -- |	//      ...if PTE caused fault: we are loading a leaf page into memory
-- -- -- -- |	
-- -- -- -- |	//update page table
-- -- -- -- |	// get the PDE (don't just use the faulted PTE; we still don't know if that is a PDE or PTE)
-- -- -- -- |	//  if the PDE was the one that faulted, it should have been !R,W
-- -- -- -- |	//      now the page table it points to is in memory, mark the PDE as R,!W
-- -- -- -- |	//          the page table is write protected because it is clean compared to disk
-- -- -- -- |	//      mark the PDE as !F,!D since the page table is clean and newly loaded
-- -- -- -- |	//          handling this fault does not count as accessing/referencing the newly loaded page table
-- -- -- -- |	//          a subsequent read, or handling a PTE fault, would mark the PDE as referenced, though
-- -- -- -- |	//      update the PDE with the new physical page where the page table was put (local var at 0x1C)
-- -- -- -- |	//      done
-- -- -- -- |	//  if the PDE was not the one that faulted, it should have been R,W
-- -- -- -- |	//      mark the PDE as F,D since we will be updating the page table with the newly loaded leaf page's information
-- -- -- -- |	//          F bit should have been set before MMU faulted on the page anyway, since we read the page table
-- -- -- -- |	//      the PTE should have been the one that faulted; the leaf page was just loaded into memory
-- -- -- -- |	//          the PTE should be !R,W
-- -- -- -- |	//          get the PTE by following the PDE to the page table
-- -- -- -- |	//          set the PTE to R,!W
-- -- -- -- |	//              R because the page is now resident in memory and safe to read
-- -- -- -- |	//              !W because the page is clean compared to disk (it was just loaded)
-- -- -- -- |	//          mark the PTE as !F,!D since the leaf page is clean and newly loaded
-- -- -- -- |	//              F bit will be set when the instruction is retried, but loading the page right now doesn't count as reference
-- -- -- -- |	//          update the PTE with the new physical page where the page table was put (local var at 0x1C)
-- -- -- -- |	//      done
-- -- -- -- |	
-- -- -- -- |	//get PDE
00 00 01 C4 |	    05 ALUM //left shift
00 00 01 C6 |	    GPD ALUA //active process page directory physical page
00 00 01 C8 |	    0C ALUB //12 bits
00 00 01 CA |	    ALUR GPA //GPA = page directory base address
-- -- -- -- |	
-- -- -- -- |	    //page table number = (virtual address & 0xFFC00000) >> 22
00 00 01 CC |	    08 ALUM //AND
00 00 01 CE |	    GPB ALUA //virtual address
00 00 01 D0 |	    IADF ALUB //mask for first 12 bits
00 00 01 D2 |	    SKIP PC
00 00 01 D4 |	    FF C0 00 00
-- -- -- -- |	
00 00 01 D8 |	    ALUR ALUA
00 00 01 DA |	    06 ALUM //right shift
00 00 01 DC |	    14 ALUB //20 bits (page number is given by shifting 22 bits, but offset into page table is page number * 4, so shift left 2 bits)
-- -- -- -- |	
00 00 01 DE |	    ALUR ALUB
00 00 01 E0 |	    GPA ALUA
00 00 01 E2 |	    07 ALUM //OR
-- -- -- -- |	
00 00 01 E4 |	    01 ALUM //add
00 00 01 E6 |	    ALUR ALUA //page directory entry physical address
00 00 01 E8 |	    IADF ALUB //add 0x00 3F 00 00 to get kernel virtual address of physical address
00 00 01 EA |	    SKIP PC
00 00 01 EC |	    00 3F 00 00
-- -- -- -- |	
00 00 01 F0 |	    BREAK
-- -- -- -- |	    //set RBASE to point to the PDE for the faulted address (may or may not be the PDE/PTE that faulted)
00 00 01 F2 |	    ALUR RBASE
00 00 01 F4 |	    00 ROFST
-- -- -- -- |	
-- -- -- -- |	//check if PDE or PTE faulted
-- -- -- -- |	//  PDE faulted if the PDE is !R,W
-- -- -- -- |	//  else PTE faulted (if PTE faulted, PDE is necessarily R,W, else it would have faulted first)
-- -- -- -- |	    //extract RW bits from PDE
00 00 01 F6 |	        RMEM ALUA //PDE to ALU
00 00 01 F8 |	        IADF ALUB //protection mask to ALU
00 00 01 FA |	        SKIP PC
00 00 01 FC |	        C0 00 00 00 //mask for the RW bits of the PDE
00 00 02 00 |	        08 ALUM //AND mode
-- -- -- -- |	
00 00 02 02 |	        ALUR ALUA //RW bits to ALU
00 00 02 04 |	        1E ALUB //shift 30 bits right
00 00 02 06 |	        06 ALUM //right shift mode
-- -- -- -- |	
-- -- -- -- |	    //compare PDE RW bits to !R,W (0x01)
00 00 02 08 |	        ALUR COMPA //RW bits to comparator
00 00 02 0A |	        01 COMPB //!R,W (0x01) to comparator
00 00 02 0C |	        COMPR PC
00 00 02 0E |	        :table_caused_r0w1 //the PDE faulted, so we just loaded a page table into memory
00 00 02 12 |	        :leaf_caused_r0w1 //the PTE faulted, so we just loaded a leaf page into memory
-- -- -- -- |	
-- -- -- -- |	@table_caused_r0w1 //IF CLAUSE (PDE faulted)
-- -- -- -- |	//if PDE faulted, we just loaded a page table in; update the PDE
-- -- -- -- |	//  update the PDE to be R,!W,!F,!D
00 00 02 16 |	    7F FLAG // TODO implement this
-- -- -- -- |	
-- -- -- -- |	// skip else clause
00 00 02 18 |	IADN PC
00 00 02 1A |	:conclude_r0w1
-- -- -- -- |	
-- -- -- -- |	@leaf_caused_r0w1 //ELSE CLAUSE (PTE faulted)
-- -- -- -- |	//else if PTE faulted, we just loaded a leaf page in; update the PDE and PTE
-- -- -- -- |	//  TODO //implement this
-- -- -- -- |	//  assert that the PTE is !R,W
-- -- -- -- |	//      if these are not the protection bits, neither the PDE nor PDE faulted?
-- -- -- -- |	//          we are in the !R,W branch, so one of PDE and PTE should have !R,W
-- -- -- -- |	//          since neither meet that criteria, HALT; PANIC
00 00 02 1E |	            7F FLAG
-- -- -- -- |	
-- -- -- -- |	//  update the PDE to be F,D
-- -- -- -- |	//  fetch the PTE
-- -- -- -- |	//  update the PTE to be R,!W,!F,!D
-- -- -- -- |	
-- -- -- -- |	@conclude_r0w1
-- -- -- -- |	//return from interrupt
-- -- -- -- |	//TODO implement this
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//nothing left
00 00 02 20 |	02 FPUM
00 00 02 22 |	11 FPUA
00 00 02 24 |	22 FPUB
00 00 02 26 |	FPUR GPC
00 00 02 28 |	7F FLAG
-- -- -- -- |	
00 00 02 2A |	FILL600
-- -- -- -- |	@@physical_page_map
-- -- -- -- |	//physical page map
-- -- -- -- |	
-- -- -- -- |	//=========================
-- -- -- -- |	// physical page mapping entry
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   process id
-- -- -- -- |	// 0x04 |   uint    |   directory physical page
-- -- -- -- |	// 0x08 |   uint    |   virtual page number
-- -- -- -- |	// 0x0C |   uint    |   number of references
-- -- -- -- |	// 0x10 |   uint    |   disk block number
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	//boot sequence (no owner)
00 00 06 00 |	00 00 00 00
00 00 06 04 |	00 00 00 00
00 00 06 08 |	00 00 00 00
00 00 06 0C |	00 00 00 00
00 00 06 10 |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//kernel page directory
00 00 06 14 |	00 00 00 01 //kernel process ID == 1
00 00 06 18 |	00 00 00 01 //owning page directory is this directory, kernel's page directory
00 00 06 1C |	00 00 00 00 //this is a directory
00 00 06 20 |	00 00 00 01 //kernel process references this physical page
00 00 06 24 |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//kernel page table 0
00 00 06 28 |	00 00 00 01 //kernel process ID == 1
00 00 06 2C |	00 00 00 01 //owning page directory is kernel directory
00 00 06 30 |	00 00 00 00 //virtual table 0
00 00 06 34 |	00 00 00 01 //kernel process references this physical page
00 00 06 38 |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//kernel virtual page 0
00 00 06 3C |	00 00 00 01 //kernel process ID == 1
00 00 06 40 |	00 00 00 01 //owning page directory is kernel directory
00 00 06 44 |	00 00 00 00 //virtual page 0
00 00 06 48 |	00 00 00 01 //kernel process references this physical page
00 00 06 4C |	00 00 00 00 //no disk block number, can never be evicted
-- -- -- -- |	
-- -- -- -- |	//empty (no owner)
00 00 06 50 |	00 00 00 00
00 00 06 54 |	00 00 00 00
00 00 06 58 |	00 00 00 00
00 00 06 5C |	00 00 00 00
00 00 06 60 |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//user page directory
00 00 06 64 |	00 00 00 02 //user process ID == 2
00 00 06 68 |	00 00 00 05 //owning page directory is this directory, user's page directory
00 00 06 6C |	00 00 00 00 //this is a directory
00 00 06 70 |	00 00 00 01 //user process references this physical page
00 00 06 74 |	00 00 00 00 //no disk block number yet
-- -- -- -- |	
-- -- -- -- |	//user page table 0
00 00 06 78 |	00 00 00 02 //user process ID == 2
00 00 06 7C |	00 00 00 05 //owning page directory is user page directory
00 00 06 80 |	00 00 00 00 //virtual table 0
00 00 06 84 |	00 00 00 01 //user process references this physical page
00 00 06 88 |	00 00 00 00 //no disk block number yet
-- -- -- -- |	
-- -- -- -- |	//user virtual page 0
00 00 06 8C |	00 00 00 02 //user process ID == 2
00 00 06 90 |	00 00 00 05 //owning page directory is user page directory
00 00 06 94 |	00 00 00 00 //virtual page 0
00 00 06 98 |	00 00 00 01 //user process references this physical page
00 00 06 9C |	00 00 00 64 //loaded from disk block 100
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//empty (no owner)
00 00 06 A0 |	00 00 00 00
00 00 06 A4 |	00 00 00 00
00 00 06 A8 |	00 00 00 00
00 00 06 AC |	00 00 00 00
00 00 06 B0 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 06 B4 |	00 00 00 00
00 00 06 B8 |	00 00 00 00
00 00 06 BC |	00 00 00 00
00 00 06 C0 |	00 00 00 00
00 00 06 C4 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 06 C8 |	00 00 00 00
00 00 06 CC |	00 00 00 00
00 00 06 D0 |	00 00 00 00
00 00 06 D4 |	00 00 00 00
00 00 06 D8 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 06 DC |	00 00 00 00
00 00 06 E0 |	00 00 00 00
00 00 06 E4 |	00 00 00 00
00 00 06 E8 |	00 00 00 00
00 00 06 EC |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 06 F0 |	00 00 00 00
00 00 06 F4 |	00 00 00 00
00 00 06 F8 |	00 00 00 00
00 00 06 FC |	00 00 00 00
00 00 07 00 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 07 04 |	00 00 00 00
00 00 07 08 |	00 00 00 00
00 00 07 0C |	00 00 00 00
00 00 07 10 |	00 00 00 00
00 00 07 14 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 07 18 |	00 00 00 00
00 00 07 1C |	00 00 00 00
00 00 07 20 |	00 00 00 00
00 00 07 24 |	00 00 00 00
00 00 07 28 |	00 00 00 00
-- -- -- -- |	//empty (no owner)
00 00 07 2C |	00 00 00 00
00 00 07 30 |	00 00 00 00
00 00 07 34 |	00 00 00 00
00 00 07 38 |	00 00 00 00
00 00 07 3C |	00 00 00 00
-- -- -- -- |	
-- -- -- -- |	//end physical page map (16 page mappings)
00 00 07 40 |	FILL840
-- -- -- -- |	@@process_map
-- -- -- -- |	//process map
-- -- -- -- |	
-- -- -- -- |	//=========================
-- -- -- -- |	// process map entry
-- -- -- -- |	//==========
-- -- -- -- |	// 0x00 |   uint    |   process id
-- -- -- -- |	// 0x04 |   uint    |   number of mapped virtual pages
-- -- -- -- |	// 0x08 |   uint    |   number of pages resident in memory
-- -- -- -- |	// 0x0C |   uint    |   disk block of process page directory
-- -- -- -- |	//=========================
-- -- -- -- |	
-- -- -- -- |	//kernel process descriptor
00 00 08 40 |	00 00 00 01 //kernel process ID == 1
00 00 08 44 |	00 00 00 03 //3 pages are mapped: 2 pages of memory and 1 mapped to the MMU
00 00 08 48 |	00 00 00 03 //page directory, page table, 1 page of memory
00 00 08 4C |	00 00 00 00 //no disk block number, kernel page directory can never be evicted
-- -- -- -- |	
-- -- -- -- |	//user process descriptor
00 00 08 50 |	00 00 00 01 //user process ID == 2
00 00 08 54 |	00 00 00 03 //2 pages are mapped: 2 pages of memory
00 00 08 58 |	00 00 00 03 //page directory, page table, 1 page of memory
00 00 08 5C |	00 00 00 00 //TODO figure out if we're supposed to load process page directory from disk...
-- -- -- -- |	            //(it should probably be built dynamically from some kind of description file
-- -- -- -- |	            // that the kernel can read to determine how many pages of the program are
-- -- -- -- |	            // mapped out of the box [length of program data])
-- -- -- -- |	
-- -- -- -- |	//end process map (16 process descriptors)
00 00 08 60 |	FILL940
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//=========================================================================
-- -- -- -- |	// [function] get_open_physical_page | void TODO: this is not void
-- -- -- -- |	//=========================================================================
-- -- -- -- |	@@get_open_physical_page
-- -- -- -- |	//returns physical page number that is available for incoming page
-- -- -- -- |	//may or may not result in page eviction
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	//calculate address where return value should be stored
00 00 09 40 |	    03 ALUM //subtract
00 00 09 42 |	    WBASE ALUA //original FP
00 00 09 44 |	    54 ALUB // -84
00 00 09 46 |	    ALUR GPH //GPH = result address = FP - 84
-- -- -- -- |	
-- -- -- -- |	//look for open pages, which we can use without evicting anything
-- -- -- -- |	//open pages have a process ID of 0
-- -- -- -- |	
-- -- -- -- |	//iterate over physical page map
-- -- -- -- |	    //point RMEM to physical page map array
00 00 09 48 |	        IADF RBASE
00 00 09 4A |	        SKIP PC
00 00 09 4C |	        ::physical_page_map
00 00 09 50 |	        00 ROFST
-- -- -- -- |	
00 00 09 52 |	    00 GPA //GPA = index
00 00 09 54 |	    10 GPB //GPB = max_index
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop
-- -- -- -- |	    //check if we're at the end of the loop (index == 16?)
00 00 09 56 |	        GPA COMPA
00 00 09 58 |	        GPB COMPB
00 00 09 5A |	        COMPR PC
00 00 09 5C |	        :open_page_loop_end
00 00 09 60 |	        :open_page_loop_go
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop_go
-- -- -- -- |	    //calculate offset from index
00 00 09 64 |	        02 ALUM //multiply mode
00 00 09 66 |	        GPA ALUA // ALUA = index
00 00 09 68 |	        14 ALUB //20 bytes per entry
00 00 09 6A |	        ALUR ROFST
-- -- -- -- |	
-- -- -- -- |	    //read process ID (offset 0)
00 00 09 6C |	    RMEM GPC //GPC = process id
-- -- -- -- |	
-- -- -- -- |	    //process id == 0?
00 00 09 6E |	        GPC COMPA
00 00 09 70 |	        00 COMPB
00 00 09 72 |	        COMPR PC
00 00 09 74 |	        :open_page_proc_id_0
00 00 09 78 |	        :open_page_loop_next
-- -- -- -- |	    
-- -- -- -- |	    @open_page_proc_id_0
-- -- -- -- |	    // found an open page
-- -- -- -- |	    // return the index as the open physical page
00 00 09 7C |	        WBASE ALUA //store FP somewhere
00 00 09 7E |	        GPH WBASE //point WMEM to the result address
00 00 09 80 |	        00 WOFST
00 00 09 82 |	        GPA WMEM //result = index
00 00 09 84 |	        ALUA WBASE //restore FP
00 00 09 86 |	        LINK PC //return
-- -- -- -- |	
-- -- -- -- |	    
-- -- -- -- |	
-- -- -- -- |	    @open_page_loop_next
-- -- -- -- |	    //increment index
00 00 09 88 |	        01 ALUM //add mode
00 00 09 8A |	        GPA ALUA
00 00 09 8C |	        01 ALUB
00 00 09 8E |	        ALUR GPA //index += 1
-- -- -- -- |	    //go to start of loop
00 00 09 90 |	    IADN PC
00 00 09 92 |	    :open_page_loop
-- -- -- -- |	
-- -- -- -- |	    //TODO implement this
-- -- -- -- |	
-- -- -- -- |	
-- -- -- -- |	@open_page_loop_end
-- -- -- -- |	//no open pages
00 00 09 96 |	BREAK
-- -- -- -- |	
-- -- -- -- |	//      TODO important insight:
-- -- -- -- |	//      An evictable page is one where no other non-empty page mapping entry has a "directory physical page" that
-- -- -- -- |	//      matches the evictable page's physical page (this is true of all leaf pages, all page tables with
-- -- -- -- |	//      no child pages in memory, and all page directories with no child tables in memory -- except page
-- -- -- -- |	//      directories point to themselves, so never count self reference)
-- -- -- -- |	//      TODO the above is only true if leaf pages point to their page tables; right now, the "directory physical page"
-- -- -- -- |	//      variable points to the owning process's page directory
-- -- -- -- |	//          Why is it set up that way? To make it easy to see if a process has any non-directory tables or pages in memory?
-- -- -- -- |	//          It should be possible to find the owning process of any page mapping entry by following the "directory physical page"
-- -- -- -- |	//          pointer until it references itself (only true of directories), which is at most 2 steps (2 for leafs, 1 for tables)
-- -- -- -- |	//          The process descriptor in the process map also has the number of resident pages
-- -- -- -- |	
-- -- -- -- |	//TODO implement this
00 00 09 98 |	00 RBASE
00 00 09 9A |	00 ROFST
00 00 09 9C |	7F RMEM
-- -- -- -- |	
-- -- -- -- |	//return
00 00 09 9E |	LINK PC
